2/3/2018 7:40:12 PM Opened Log!
2/3/2018 7:40:12 PM Starting server...
2/3/2018 7:40:12 PM Server is being hosted on Darian/127.0.0.1:10000
2/3/2018 7:40:33 PM New User Connected from /127.0.0.1:54660
2/3/2018 7:40:39 PM Removing a user: GUEST
2/3/2018 7:44:44 PM Opened Log!
2/3/2018 7:44:44 PM Starting server...
2/3/2018 7:44:44 PM Server is being hosted on Darian/127.0.0.1:10000
2/3/2018 7:44:52 PM New User Connected from /127.0.0.1:54661
2/3/2018 7:46:40 PM Opened Log!
2/3/2018 7:46:41 PM Starting server...
2/3/2018 7:46:41 PM Server is being hosted on Darian/127.0.0.1:10000
2/3/2018 7:47:00 PM New User Connected from /127.0.0.1:54662
2/3/2018 7:47:13 PM SERVER ADMIN: hello
2/3/2018 7:47:13 PM [SERVER] hello
2/3/2018 7:47:16 PM SERVER ADMIN: how is it going?
2/3/2018 7:47:16 PM [SERVER] how is it going?
2/3/2018 7:47:25 PM [Darian] hi
2/3/2018 7:47:59 PM [Darian] Ok, so
2/3/2018 7:48:05 PM [Darian] THis thing needs fixed up
2/3/2018 7:48:34 PM [Darian] tis ok
2/3/2018 7:51:06 PM SERVER ADMIN: so you want my program
2/3/2018 7:51:06 PM [SERVER] so you want my program
2/3/2018 7:51:07 PM SERVER ADMIN: /list
2/3/2018 7:51:07 PM [SERVER] /list
2/3/2018 7:51:08 PM SERVER ADMIN: /help
2/3/2018 7:51:08 PM /halt - halt the server
2/3/2018 7:51:08 PM /mmon - turn the match maker on and off
2/3/2018 7:51:08 PM /stop - stop the server
2/3/2018 7:51:08 PM /debug - enable debug mode
2/3/2018 7:51:08 PM /open - open server socket, if it is not already open
2/3/2018 7:51:08 PM /close - close server socket, stop accepting connections
2/3/2018 7:51:08 PM /ttps <int> - set target tps for server
2/3/2018 7:52:49 PM [Darian] Whelp
2/3/2018 7:52:55 PM [Darian] what do i do now?
2/3/2018 7:53:34 PM Opened Log!
2/3/2018 7:53:35 PM Starting server...
2/3/2018 7:53:35 PM Server is being hosted on Darian/192.168.1.122:10000
2/3/2018 7:53:51 PM New User Connected from /127.0.0.1:54714
2/3/2018 7:54:07 PM [GUEST - Darian] oh yeah
2/3/2018 7:55:08 PM SERVER ADMIN: /help
2/3/2018 7:55:08 PM /halt - halt the server
2/3/2018 7:55:08 PM /mmon - turn the match maker on and off
2/3/2018 7:55:08 PM /stop - stop the server
2/3/2018 7:55:08 PM /debug - enable debug mode
2/3/2018 7:55:08 PM /open - open server socket, if it is not already open
2/3/2018 7:55:08 PM /close - close server socket, stop accepting connections
2/3/2018 7:55:08 PM /ttps <int> - set target tps for server
2/3/2018 7:55:14 PM SERVER ADMIN: /halt
2/3/2018 7:55:14 PM Server activity halted!
2/3/2018 7:55:14 PM [SERVER] Server activity halted!
2/3/2018 7:55:20 PM SERVER ADMIN: /halt
2/3/2018 7:55:20 PM Server activity no longer halted
2/3/2018 7:55:20 PM [SERVER] Server activity no longer halted
2/3/2018 7:55:24 PM SERVER ADMIN: /ttps 50
2/3/2018 7:55:24 PM Target tps set to 50
2/3/2018 7:55:28 PM SERVER ADMIN: /ttps 10000
2/3/2018 7:55:28 PM Target tps set to 10000
2/3/2018 7:55:34 PM SERVER ADMIN: /ttps 1000000
2/3/2018 7:55:34 PM Target tps set to 1000000
2/3/2018 7:55:43 PM SERVER ADMIN: /halt
2/3/2018 7:55:43 PM Server activity halted!
2/3/2018 7:55:43 PM [SERVER] Server activity halted!
2/3/2018 7:55:47 PM SERVER ADMIN: /halt
2/3/2018 7:55:47 PM Server activity no longer halted
2/3/2018 7:55:47 PM [SERVER] Server activity no longer halted
2/3/2018 7:55:53 PM SERVER ADMIN: /ttps 10
2/3/2018 7:55:53 PM Target tps set to 10
2/3/2018 7:59:56 PM [GUEST - Darian] Yo se, billy la bufanda es una bufanda
2/3/2018 8:00:05 PM [GUEST - Darian] no tiene ojos
2/3/2018 8:00:12 PM [GUEST - Darian] no puede comar nada
2/3/2018 8:00:16 PM [GUEST - Darian] es una bufanda
2/3/2018 8:01:12 PM SERVER ADMIN: /ttps 1000
2/3/2018 8:01:12 PM Target tps set to 1000
2/3/2018 8:01:32 PM SERVER ADMIN: /ttps 2000
2/3/2018 8:01:32 PM Target tps set to 2000
2/3/2018 8:01:55 PM SERVER ADMIN: /ttps 20
2/3/2018 8:01:55 PM Target tps set to 20
2/3/2018 8:02:01 PM SERVER ADMIN: /ttps 1000
2/3/2018 8:02:01 PM Target tps set to 1000
2/3/2018 8:02:14 PM SERVER ADMIN: /ttps 10000
2/3/2018 8:02:14 PM Target tps set to 10000
2/3/2018 8:03:49 PM SERVER ADMIN: /ttps 20
2/3/2018 8:03:49 PM Target tps set to 20
2/3/2018 8:07:36 PM [GUEST - Darian] what if i had a tictactoe game for while users where waiting
2/3/2018 8:13:53 PM SERVER ADMIN: /close
2/3/2018 8:13:53 PM Stopping server socket handler...
2/3/2018 8:14:02 PM SERVER ADMIN: /open
2/3/2018 8:14:02 PM Opening server socket handler...
2/3/2018 8:14:04 PM SERVER ADMIN: /close
2/3/2018 8:14:04 PM Stopping server socket handler...
2/3/2018 8:14:07 PM SERVER ADMIN: /open
2/3/2018 8:14:07 PM Opening server socket handler...
2/3/2018 8:14:11 PM SERVER ADMIN: /debug
2/3/2018 8:14:11 PM [DEBUG] true
2/3/2018 8:14:13 PM SERVER ADMIN: /close
2/3/2018 8:14:13 PM Stopping server socket handler...
2/3/2018 8:14:15 PM SERVER ADMIN: /open
2/3/2018 8:14:15 PM Opening server socket handler...
2/3/2018 8:14:15 PM [DEBUG] Took 1.97097E-4 Seconds to start the server socket handler.
2/3/2018 8:14:50 PM SERVER ADMIN: Server has been running for a fair amount of time
2/3/2018 8:14:50 PM [SERVER] Server has been running for a fair amount of time
2/3/2018 8:14:56 PM SERVER ADMIN: which is great, i guess
2/3/2018 8:14:56 PM [SERVER] which is great, i guess
2/3/2018 8:15:04 PM SERVER ADMIN: oos = new ObjectOutputStream(dos);
2/3/2018 8:15:04 PM [SERVER] oos = new ObjectOutputStream(dos);
2/3/2018 8:15:06 PM SERVER ADMIN: oooh
2/3/2018 8:15:06 PM [SERVER] oooh
2/3/2018 8:15:07 PM SERVER ADMIN: i can
2/3/2018 8:15:07 PM [SERVER] i can
2/3/2018 8:15:08 PM SERVER ADMIN: oos = new ObjectOutputStream(dos);
2/3/2018 8:15:08 PM [SERVER] oos = new ObjectOutputStream(dos);
2/3/2018 8:15:20 PM SERVER ADMIN: ckTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }
2/3/2018 8:15:20 PM [SERVER] ckTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }
2/3/2018 8:15:33 PM SERVER ADMIN: import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }
2/3/2018 8:15:33 PM [SERVER] import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }
2/3/2018 8:16:18 PM Opened Log!
2/3/2018 8:16:18 PM Starting server...
2/3/2018 8:16:18 PM Server is being hosted on Darian/192.168.1.122:10000
2/3/2018 8:16:29 PM SERVER ADMIN: /debug
2/3/2018 8:16:29 PM [DEBUG] true
2/3/2018 8:16:30 PM SERVER ADMIN: /close
2/3/2018 8:16:30 PM Stopping server socket handler...
2/3/2018 8:16:31 PM SERVER ADMIN: /open
2/3/2018 8:16:31 PM Opening server socket handler...
2/3/2018 8:16:31 PM [DEBUG] Took 2.13333E-4 Seconds to start the server socket handler.
2/3/2018 8:16:40 PM New User Connected from /127.0.0.1:54749
2/3/2018 8:16:50 PM SERVER ADMIN: import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }
2/3/2018 8:16:50 PM [SERVER] import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }
2/3/2018 8:16:53 PM SERVER ADMIN: import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }
2/3/2018 8:16:53 PM [SERVER] import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }
2/3/2018 8:16:56 PM SERVER ADMIN: import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }
2/3/2018 8:16:56 PM [SERVER] import java.util.ArrayList; public class Server implements Runnable,InputUser {     private ServerSocketHandler connectHandler;     private Terminal term;     private DataDisplay disp;     private boolean usingTerm = false;     private ArrayList<User> Users = new ArrayList<User>();     private int maxUsers = 50;     private boolean going = false;     private boolean halted = false;     private boolean mmon = true;     private int tps = 0;     private double tickTime = 0;     private Logger logger = new Logger();     private boolean debug = false;     private int dispLabelCount = 13;     private int totalBytesSent = 0;     private long startTime = System.nanoTime();     private int targetTps = 20;          public static void main(String args[]) {         Server s = new Server();         if(args.length>0) {             if(args[0].equals("debug")) {                 s.inputText("/debug");             }         }         s.openTerm();         s.start();     }          public void calcTotalBytesSent() {         totalBytesSent = 0;         for(int i=0; i<Users.size(); i++) {             SocketHandler s = Users.get(i).getSocketHandler();             totalBytesSent+=s.getSize();         }     }          public boolean isHalted() {         return halted;     }      public void start() {         new Thread(this).start();     }      public void setMaxPlayers(int x) {         maxUsers=x;     }      public void stop() {         going=false;     }      public boolean listIsFull() {         return Users.size()>=maxUsers;     }      public void addUser(SocketHandler s) {         User p = new User(s,this);         MainMenu m = new MainMenu();         m.setUser(p);         p.setHandler(m);         Users.add(p);         out("New User Connected from "+s.getAddress());     }          public int getUserCount() {         return Users.size();     }          public void startSocketHandler() {         if(!connectHandler.isFinished()) {             out("Could not start server socket handler: It's already started!");             return;         }         try{             long time2 = System.nanoTime();             connectHandler.setup();             debug("Took "+((double)(System.nanoTime()-time2)/1000000000)+" Seconds to start the server socket handler.");             connectHandler.setTimeout(1);             connectHandler.setWaitTime(100);         }catch(Exception e) {             out("Could not start server socket handler");             debug(e.getStackTrace()+"");             return;         }     }          public void createSocketHandler() {         try{             connectHandler = new ServerSocketHandler(this);         }catch(Exception e) {             out("Could not create ServerSocketHandler");             debug(e.getStackTrace()+"");         }     }      public void run() {         out("Starting server...");         long time1 = System.nanoTime();                  createSocketHandler();                  startSocketHandler();                  out("Server is being hosted on "+getAddress());         going=true;         debug("Took "+((double)(System.nanoTime()-time1)/1000000000)+" Seconds to start the server.");         time1=System.nanoTime();         int tps2=0;         while(going) {             long tickStart = System.nanoTime();             try{                 //if(!halted) Thread.sleep(0);                 if(!halted) Thread.sleep(1000 / targetTps);                 else Thread.sleep(1000 / 1);             }catch(Exception e) {              }                          tickStart = System.nanoTime();                          //System.gc();                          removeUnconnected();             if(usingTerm) {                 disp.setText(0, "Users: " + Users.size() );                 disp.setText(1, "Host Address: " + getAddress() );                 disp.setText(2, "TPS: " + tps );                 disp.setText(3, "Halted: " + halted );                 disp.setText(4, "Tick Time: " + tickTime + " ms" );                 //disp.setText(5, "Matches: " + matches.size() );                 //disp.setText(6, "Players in MatchMaker: "+ mm.getQueueSize() );                 disp.setText(7, "Bytes Sent: " + totalBytesSent );                 disp.setText(8, "Free Mem: " + Runtime.getRuntime().freeMemory() );                 disp.setText(9, "Total Mem: " + Runtime.getRuntime().totalMemory() );                 disp.setText(10, "Used Mem: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() ) );                 disp.setText(11, "Used %: " + (100 * (double)(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()) / (double)Runtime.getRuntime().totalMemory()));                 disp.setText(12, "Uptime: "+( (double) ( System.nanoTime() - startTime ) / 1000000000.0 ) + "s");             }              if(mmon && !halted) {                 //mm.run();                 //endMatches();             }                          if(!logger.canWrite) logger.reopen();              tickTime = ( ( System.nanoTime() - (double)tickStart ) ) / 1000000;                          tps2++;             if(System.nanoTime() - time1 >= 1000000000) {                 tps=tps2;                 time1=System.nanoTime();                 tps2=0;                 calcTotalBytesSent();             }         }         out("Closing Server...");         sendAll("Closing Server...");         //endAllMatches();         //endMatches();         connectHandler.stop();         for(int i=0; i<Users.size(); i++) {             Users.get(i).disconnect();         }         removeUnconnected();          logger.close();                  closeTerm();                  out("Server Closed");     }      public void removeUnconnected() {         for(int i=0; i<Users.size(); i++) {             SocketHandler p = Users.get(i).getSocketHandler();             if(p.isConnected()==false) {                 out("Removing a user: "+Users.get(i).getName());                 Users.remove(i);                              }         }     }      public void inputText(String i) {         logger.log("SERVER ADMIN: "+i);         if(i.equals("/help")) {             out("/halt - halt the server");             out("/mmon - turn the match maker on and off");             out("/stop - stop the server");             out("/debug - enable debug mode");             out("/open - open server socket, if it is not already open");             out("/close - close server socket, stop accepting connections");             out("/ttps <int> - set target tps for server");         }         else if(i.equals("/stop")) {             stop();         }         else if(i.equals("/halt")) {             halted=!halted;             if(halted) {                 out("Server activity halted!");                 sendAll("Server activity halted!");             }             else {                 out("Server activity no longer halted");                 sendAll("Server activity no longer halted");             }         }         else if(i.equals("/mmon")) {             mmon=!mmon;             out("MatchMaker on: "+mmon);             if(mmon) sendAll("MatchMaker Enabled");             else sendAll("MatchMaker Disabled");         }         else if(i.equals("/debug")) {             debug=!debug;             debug(debug+"");         }         else if(i.equals("/close")) {             out("Stopping server socket handler...");             connectHandler.stop();         }         else if(i.equals("/open")) {             out("Opening server socket handler...");             startSocketHandler();         }         else if(Command.is("/ttps",i)) {             int x;             try{                 x = Integer.parseInt( Command.getArgs(i).get(1));             }catch(Exception e) {                 out("Please enter an integer!");                 return;             }             targetTps=x;             out("Target tps set to "+x);         }         else sendAll(i);     }      public void sendAll(User u, String s) {         out("["+u.getName()+"] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("["+u.getName()+"] "+s);         }     }      public void sendAll(String s) {         out("[SERVER] "+s);         for(int i=0; i<Users.size(); i++) {             Users.get(i).send("[SERVER] "+s);         }     }          public void debug(String o) {         if(debug) {             out("[DEBUG] "+o);         }     }      public void out(String o) {         if(usingTerm) {             term.write(o);         }         logger.log(o);     }      public void openTerm() {         term=new Terminal();         term.setUser(this);         term.setTitle("Server Terminal");         disp = new DataDisplay(dispLabelCount);         usingTerm=true;     }      public void closeTerm() {         term.setVisible(false);         disp.setVisible(false);         usingTerm=false;     }      public int getPort() {         if(connectHandler==null) {             return -1;         }         return connectHandler.getPort();     }      public String getAddress() {         try{              return ""+connectHandler.getSocket().getInetAddress().getLocalHost()+":"+getPort();         }catch(Exception e) {             return null;         }     }      public ServerSocketHandler getServerSocketHandler() {         return connectHandler;     } }
2/3/2018 8:21:24 PM New User Connected from /127.0.0.1:54752
2/3/2018 8:22:09 PM Removing a user: GUEST - Darian
2/3/2018 8:22:35 PM Opened Log!
2/3/2018 8:22:35 PM Starting server...
2/3/2018 8:22:35 PM Server is being hosted on Darian/192.168.1.122:10000
2/3/2018 8:23:06 PM New User Connected from /127.0.0.1:54754
2/3/2018 8:23:12 PM [GUEST] Hola
2/3/2018 8:23:53 PM Removing a user: GUEST
2/3/2018 8:23:58 PM SERVER ADMIN: /stop
2/3/2018 8:23:58 PM Closing Server...
2/3/2018 8:23:58 PM [SERVER] Closing Server...
2/3/2018 8:24:58 PM Opened Log!
2/3/2018 8:24:58 PM Starting server...
2/3/2018 8:24:58 PM Server is being hosted on Darian/192.168.1.122:10000
2/3/2018 8:25:05 PM Opened Log!
2/3/2018 8:25:05 PM Starting server...
2/3/2018 8:25:05 PM Server is being hosted on Darian/192.168.1.122:10000
2/3/2018 8:25:05 PM New User Connected from /127.0.0.1:54757
2/3/2018 8:26:49 PM Opened Log!
2/3/2018 8:26:49 PM Starting server...
2/3/2018 8:26:49 PM Server is being hosted on Darian/192.168.1.122:10000
2/3/2018 8:26:49 PM New User Connected from /127.0.0.1:54766
2/3/2018 8:32:31 PM Opened Log!
2/3/2018 8:32:31 PM Starting server...
2/3/2018 8:32:31 PM Server is being hosted on Darian/192.168.1.122:10000
2/3/2018 8:32:38 PM SERVER ADMIN: /debug
2/3/2018 8:32:38 PM [DEBUG] true
2/3/2018 8:32:39 PM SERVER ADMIN: /close
2/3/2018 8:32:39 PM Stopping server socket handler...
2/3/2018 8:32:40 PM SERVER ADMIN: /open
2/3/2018 8:32:40 PM Opening server socket handler...
2/3/2018 8:32:40 PM [DEBUG] Took 0.001253191 Seconds to start the server socket handler.
